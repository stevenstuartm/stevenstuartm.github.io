{
  "quadrants": [
    { "name": "Tools" },
    { "name": "Techniques" },
    { "name": "Platforms" },
    { "name": "Languages & Frameworks" }
  ],
  "rings": [
    { "name": "ADOPT", "color": "#5ba300" },
    { "name": "TRIAL", "color": "#009eb0" },
    { "name": "ASSESS", "color": "#c7ba00" },
    { "name": "HOLD", "color": "#e09b96" }
  ],
  "entries": [
    { "label": "VS Code", "quadrant": 0, "ring": 0, "moved": 1, "description": "The most versatile and well-supported development environment available. Microsoft's backing ensures long-term stability, extensive plugin ecosystem, and continuous improvement. Works seamlessly across languages and platforms." },
    { "label": "Terraform", "quadrant": 0, "ring": 2, "moved": 0, "description": "Still evaluating Terraform vs. cloud-native solutions (CloudFormation, CDK). Infrastructure automation is evolving rapidly with AI assistance changing the landscape. Terraform's state management complexity and the limitations of cross-platform abstraction are concerns. Monitoring how this space develops." },
    { "label": "AWS CloudFormation", "quadrant": 0, "ring": 2, "moved": 0, "description": "Assessing infrastructure-as-code options. Native AWS solutions like CloudFormation and CDK appear to accumulate less technical debt than multi-cloud abstractions. Tight AWS integration and first-class support for new services are advantages, though vendor lock-in is a tradeoff." },
    { "label": "N8N", "quadrant": 0, "ring": 2, "moved": 0, "description": "Workflow automation platform with extensive integration capabilities. Interesting alternative to building custom async workers for internal processes and lower-volume workloads. Not suitable for high-throughput production systems, but compelling for operational workflows, internal tools, and personal automation." },

    { "label": "Domain-Driven Design", "quadrant": 1, "ring": 0, "moved": 1, "description": "My preferred approach for designing distributed systems. DDD doesn't force monolith vs. microservices decisions prematurely—bounded contexts let you discover boundaries and scale incrementally. Supports modular monoliths that can split when needed. Requires architectural governance but empowers teams to make detailed design decisions. Most effective for behavior-driven systems rather than pure entity-management scenarios." },
    { "label": "Test-Driven Development", "quadrant": 1, "ring": 0, "moved": 1, "description": "Essential practice for writing maintainable code. TDD encourages SOLID principles, user-focused design, and explicit testing of assumptions. Particularly valuable for developers building architectural discipline, but beneficial for all engineers. Forces consideration of use cases over isolated functions." },
    { "label": "Trunk-Based Development", "quadrant": 1, "ring": 0, "moved": 1, "description": "Critical for effective CI/CD. Enables faster feedback loops, eliminates work based on stale code, and significantly improves system stability. Teams committed to continuous delivery should adopt this practice." },
    { "label": "REST", "quadrant": 1, "ring": 0, "moved": 1, "description": "Still the right choice for entity-driven APIs—media libraries, inventory systems, configuration management. For business-logic-heavy operations, consider RPC-style APIs instead. Choose based on your domain characteristics, not trends." },
    { "label": "Behavior Driven Design", "quadrant": 1, "ring": 2, "moved": 0, "description": "Often misunderstood methodology—not about tools or specification formats. Originally intended to clarify TDD but became even more confused in practice. Re-evaluating current tooling and operational patterns to determine if modern BDD implementations offer practical value." },

    { "label": "AWS", "quadrant": 2, "ring": 0, "moved": 1, "description": "Primary cloud platform choice based on service longevity and stability. AWS rarely deprecates services, protecting long-term architectural investments. Azure has superior billing management and DevOps tooling, making it attractive for smaller projects. Both are viable—choose based on organizational priorities and project requirements." },
    { "label": "Kubernetes", "quadrant": 2, "ring": 3, "moved": -1, "description": "Operational complexity and upgrade instability make K8s a difficult commitment. The overhead often outweighs benefits even for large microservice deployments. Carefully evaluate whether managed container services or serverless alternatives better serve your needs before adopting." },
    { "label": "Firebase", "quadrant": 2, "ring": 3, "moved": -1, "description": "Effective for rapid prototyping and initial launches, but limitations emerge quickly in production. Lacks built-in authorization (major gap), leading to accumulating technical debt. Good for MVPs, but plan migration path early if product gains traction." },
    { "label": "MySQL", "quadrant": 2, "ring": 0, "moved": 1, "description": "Reliable, performant, and universally supported relational database. Works well for service-based architectures that avoid heavy database scripting. PostgreSQL is equally solid. Despite being a .NET developer, I prefer MySQL over SQL Server for most use cases." },
    { "label": "Redis", "quadrant": 2, "ring": 3, "moved": -1, "description": "Avoid based on repeated operational failures across multiple organizations. Stability issues persist even with cloud-managed offerings. Identity crisis (cache? database? message broker?) leads to complex, fragile implementations. Modern cloud-native services solve the same problems more reliably." },
    { "label": "Memcached", "quadrant": 2, "ring": 0, "moved": 1, "description": "Stable, cost-effective caching solution. While clustering has limitations compared to cloud-native options, its simplicity and reliability make it superior to alternatives like Redis when used appropriately. Focus on caching use cases it handles well." },
    { "label": "DynamoDB", "quadrant": 2, "ring": 0, "moved": 1, "description": "Exceptional NoSQL database for the right use cases. Extremely fast, cost-effective, scales seamlessly, integrates perfectly with event-driven architectures. Works beautifully with bounded contexts and can replace entire architectural layers. Native caching support and change-stream capabilities enable real-time data pipelines." },
    { "label": "Clerk", "quadrant": 2, "ring": 3, "moved": -1, "description": "Full-stack authentication and user management platform with excellent UI SDK support. However, the data architecture is fundamentally flawed—built around single-app use cases with users siloed per application. Cross-app support exists through satellite domains, but this is a workaround for deeper architectural limitations. Great for rapid initial deployment (faster than Firebase or Supabase), but the solution reflects the same deployment-velocity mindset it promotes, lacking long-term architectural planning. Kinde offers similar features at lower cost with better multi-tenant flexibility, multi-domain support, and architectural alignment. While Clerk's SDK advantage is notable, AI-assisted form building eliminates this gap. Consider alternatives that provide better TCO, strategic flexibility, and mature multi-tenant architecture within the same cost range." },
    { "label": "Kinde", "quadrant": 2, "ring": 0, "moved": 1, "description": "Authentication and user management platform that hits the sweet spot among available solutions. Superior cost structure compared to Auth0 and Clerk, with better multi-tenant and branding support than Firebase, Supabase, or AWS Cognito. The data architecture is organization-oriented rather than app-centric, enabling true multi-tenant scenarios without architectural workarounds. Excellent UI console surpasses competing offerings in usability and feature completeness. Simple data migration paths and holistic approach to identity management across multiple applications and domains. While Auth0, Clerk, Firebase, Supabase, AWS Cognito, and WorkOS are all viable solutions for specific use cases, Kinde balances cost, architectural flexibility, enterprise features, and developer experience better than alternatives. Strong consideration for new projects requiring authentication with growth potential." },

    { "label": "TypeScript", "quadrant": 3, "ring": 0, "moved": 1, "description": "Compile-time safety reduces bugs and improves maintainability significantly. Rich tooling and type system help teams understand code better than relying solely on tests. Some verbosity exists for teams new to type safety, but the long-term benefits—fewer runtime errors, better refactoring, clearer contracts—outweigh learning curve." },
    { "label": "Vue", "quadrant": 3, "ring": 0, "moved": 1, "description": "Lightweight, performant framework with logical separation of concerns. Uses standard HTML without JSX abstraction (unlike React), while remaining flexible and unopinionated (unlike Angular). Smaller ecosystem than competitors but growing rapidly. Best balance of performance, developer experience, and pragmatic design." },
    { "label": "NUXT", "quadrant": 3, "ring": 1, "moved": 0, "description": "Full-stack Vue framework with excellent server-side rendering and SEO support. Disciplined structure improves velocity. However, abstractions over Tailwind are problematic, and version upgrades require attention. Good for projects needing SSR/SSG, but evaluate carefully if you have extensive existing Tailwind implementations. Still assessing production readiness." },
    { "label": "Go", "quadrant": 3, "ring": 2, "moved": 0, "description": "Prefer .NET for APIs and applications, but Go remains interesting for distributed systems and performance-critical workflows. Weighing Go vs. Rust for these use cases—both have tradeoffs in learning curve and ecosystem maturity." },
    { "label": "Rust", "quadrant": 3, "ring": 2, "moved": 0, "description": "Impressive performance and safety guarantees, but significant investment in learning and team training. Better suited for systems programming, IoT, and critical async workflows than typical APIs. Not planning to use for most application development. Awaiting practical POC opportunity." },
    { "label": "GRPC", "quadrant": 3, "ring": 2, "moved": 0, "description": "Haven't needed low-latency internal communication yet. Reservations about tight coupling (reminds me of WCF). Prefer loosely coupled communication patterns, but acknowledge gRPC's performance benefits for specific scenarios. More research needed." },
    { "label": "GraphQL", "quadrant": 3, "ring": 3, "moved": -1, "description": "Effective for internal tools and reporting dashboards. However, production experience revealed it often masks architectural and organizational problems rather than solving them. Modern team topologies (vertical slices, domain ownership) eliminate the API bottleneck GraphQL was meant to solve. Security, performance, and maintenance tradeoffs are significant. Use selectively." },
    { "label": ".NET", "quadrant": 3, "ring": 0, "moved": 1, "description": "Premier platform for enterprise systems. Mature, secure, well-supported ecosystem with excellent performance. While other languages may be simpler or have cleaner evolution paths, .NET strikes the best balance between technical capability and business velocity. Continuous innovation keeps it ahead of alternatives like Java." },
    { "label": "Jekyll", "quadrant": 3, "ring": 0, "moved": 1, "description": "Rock-solid static site generator backed by GitHub Pages. Perfect for content-heavy sites—blogs, documentation, portfolios—where dynamic features aren't needed. Simple architecture (Liquid templates, YAML front matter, Markdown content) makes it maintainable without framework churn. Native GitHub Pages integration means zero-config deployment. Compile-time rendering ensures exceptional performance and security. Great for technical writing where you want version control and simplicity over CMS complexity." }
  ]
}