{
  "quadrants": [
    { "name": "Tools" },
    { "name": "Techniques" },
    { "name": "Platforms" },
    { "name": "Languages & Frameworks" }
  ],
  "rings": [
    { "name": "ADOPT", "color": "#5ba300" },
    { "name": "TRIAL", "color": "#009eb0" },
    { "name": "ASSESS", "color": "#c7ba00" },
    { "name": "HOLD", "color": "#e09b96" }
  ],
  "entries": [
    { "label": "VS Code", "quadrant": 0, "ring": 0, "moved": 0, "description": "You can build anything from anything using VsCode. And given that it is published by Microsoft, it is trusted and it is supported well beyond what most IDE's and code editors are." },
    { "label": "Terraform", "quadrant": 0, "ring": 2, "moved": 0, "description": "I am still wrestling with Terraform vs cloud native solutions, like AWS CloudFormation or even AWS CDK. The overall subject of infrastructure automation is in such a state of flux that there is little clarity on the subject and all approaches have big advantages. And AI makes it even more complex. The state management of terraform is a big red warning sign for me, and the cross-platform theory seems heavily flawed. Only time will tell." },
    { "label": "AWS CloudFormation", "quadrant": 0, "ring": 2, "moved": 0, "description": "I am still wrestling with Terraform vs cloud native solutions, like AWS CloudFormation or even AWS CDK. The overall subject of infrastructure automation is in such a state of flux that there is little clarity on the subject and all approaches have big advantages. And AI makes it even more complex. So far, I lean towards native solutions as they seem to come with less tech debt." },
    { "label": "N8N", "quadrant": 0, "ring": 2, "moved": 2, "description": "N8N is one of several most popular workflow solutions for the modern world. I can’t even begin to summarize everything it actually does. It is like Zapier and yet nothing like it at all. For personal and internal async workflows this is fascinating. It lacks the ingress rate to handle most serious production workloads, but for anything that does not have massive scale (which is most things), this is a curious alternative to building async workers and queue processors. It seems nearly limitless in what it can do and what it can be plugged into." },

    { "label": "Domain-Driven Design", "quadrant": 1, "ring": 0, "moved": 0, "description": "In my opinion, DDD is the default solution for initial distributed business design. It does not lock you into a monolith or microservices, while providing you with the time to discover your boundaries and scaling needs. You CAN use DDD in a modular monolith and only split when needed. DDD works perfectly for teams, new or existing. Bounded contexts give you the flexibility to manage your data sources as you need, when you need to, and without causing massive system disruption. It requires a bit more architectural governance but it mostly hands over the details to team design decisions. It is best of all worlds while allowing it to expand and contract quickly. Given the aspect-oriented nature of bounded contexts, if you have a mostly entity-driven product (you really need REST or graphql) then DDD may not be right for your external layers and more than that entire chunk of your system. That said, nearly all systems are behavior and not solely focused on global entity management." },
    { "label": "Test-Driven Development", "quadrant": 1, "ring": 0, "moved": 0, "description": "TTD is best for devs whose architectural discipline is yet where they want it to be. But it still useful and prudent for all devs. TTD will force you to think about SOLID and to write code that others can maintain. TTD also forces you to think about user-oriented use cases, not just functions. TTD also forces you to TEST ASSUMPTIONS about use cases as well as the characteristics of a component." },
    { "label": "Trunk-Based Development", "quadrant": 1, "ring": 0, "moved": 0, "description": "Has your team committed to true CICD? You should. Faster feedback, always working on truth and not assumptions, and gaining much more system stability." },
    { "label": "REST", "quadrant": 1, "ring": 0, "moved": 0, "description": "Nothing new, but worth a mention. If you have global entities (Media, Inventory, Tenant configuration (maybe)) then I suggest using REST. Use a more operational solution (RPC) for business objects that need business logic to manage." },
    { "label": "Behavior Driven Design", "quadrant": 1, "ring": 2, "moved": 0, "description": "Behavior Driven Design is a tricky subject because it is often so very misunderstood. It has nothing to do with tooling and nothing to do with XML specs. It was meant to address a misunderstanding in what TTD is meant to be and ironically became even more misunderstood than TTD. I used a flavor of BDD once, but I need to examine this again more closely to see if I am missing something operationally and also to look into the latest associated tooling." },

    { "label": "AWS", "quadrant": 2, "ring": 0, "moved": 0, "description": "AWS or Azure? No one really can answer that, and it does not have to be just one. But given that AWS has better long term support for services and does not drop things when they become inconvenient, as an architect I have to protect the interest of the organization. So I choose AWS … for now. For smaller projects I might favor Azure. Azure account and billing management and DevOPs support is FAR FAR better than AWS. So pick your priorities." },
    { "label": "Kubernetes", "quadrant": 2, "ring": 3, "moved": -1, "description": "The operation overhead and, at times, the unstable nature of upgrades, leaves K8s outside of what I am willing to commit to. Even if I had hundreds of microservices, I would be cautious before committing to such a velocity killer." },
    { "label": "Firebase", "quadrant": 2, "ring": 3, "moved": -1, "description": "Firebase is great for getting a new web and mobile app out of the door and quickly. But once it is deployed it becomes more and more obvious that this product is not quite mature enough to serve as a holistic fully managed solution and becomes more of a source of tech debt than a benefit with momentum. It supports authentication providers well enough, but it lacks any in-house authorization solution which, in my opinion, is a MASSIVE gap and flaw which prevents it from being a reliable long term pick." },
    { "label": "MySQL", "quadrant": 2, "ring": 0, "moved": 0, "description": "MySQL just works, works well, and runs everywhere. It comes only with what is needed for architectures which are service-based and are not glued to database scripting. Postgresql is another good option and, at times, is even more popular. I am a .Net guy, but even I prefer MySQL over MsSQL." },
    { "label": "Redis", "quadrant": 2, "ring": 3, "moved": -1, "description": "Redis deserves my scorn for the years of pain it has caused. I have been in three organizations which used Redis and I have never seen it be anything other than a crippling disaster. Even with cloud native abstractions, IT IS TOO UNSTABLE. And I stand by that statement. It also does not know what it wants to be: a cache, a DB, a broker? It is not best at anything except needing constant bug fixes in the very much needed custom adapter used to talk to Redis. Architecture is always the solution to better design and stability, and Redis is an outdated problem that solves nothing that can't be solved easily with modern cloud native services." },
    { "label": "Memcached", "quadrant": 2, "ring": 0, "moved": 1, "description": "Memcached is a good cost-effective and STABLE solution for simple caching needs. Clustering will always be a sore subject for solutions which are not cloud native, but if you focus on using the cache only for things which ought to use it, then you will find this solution much more stable and effective than other options, like Redis." },
    { "label": "DynamoDB", "quadrant": 2, "ring": 0, "moved": 1, "description": "DynamoDB is a fantastic technology when used in the right context. I could spend all day talking about every little thing that it fixes and enhances. There are entire service architectures which can be thrown away because of this ground-breaking AWS service. Very cost effective, very very very fast, scales beautifully, can act as a cache solution even without the cache layer it supports, fits very well with bounded contexts, has great even-driven support for realtime ETL. ect, ect, ect." },
    { "label": "Clerk", "quadrant": 2, "ring": 2, "moved": 2, "description": "Clerk provides full stack auth and user management — so you can launch faster, scale easier, and stay focused on building your business. I am still researching this but I will likely begin a POC on this soon. I am hopeful that this will replace my entire auth platform and as an alternative for Firebase and Superbase." },

    { "label": "TypeScript", "quadrant": 3, "ring": 0, "moved": 0, "description": "There will always be a great debate between relying solely on tests and relying more on compile time safety. TypeScript is more concerned with finding issues before they are ever committed and providing a rich set of tools. TypeScript is a reliable way to save time on bug fixing and to greatly increase the maintainability of a web app by allowing all current and future team members to actually understand what is going on. It takes a more humble approach to the reality of how humans work. But it is verbose to those who are not used to type safety. So it may not be right for all teams." },
    { "label": "Vue", "quadrant": 3, "ring": 0, "moved": 1, "description": "Vue is the most lightweight and fastest of the big JS frameworks. And it takes a much more logical approach to separating concerns. Unlike react, Vue does not require a whole new language abstraction over HTML. Unlike Angular, it does not force its opinions on you and allows you to work in more flexible intervals of discovery. It has less of a mountain of packages built for it, but it has gained ground quickly as being a more trustworthy middle ground solution while still outperforming all competitors." },
    { "label": "NUXT", "quadrant": 3, "ring": 1, "moved": 0, "description": "NUXT is built on top of node.js and for use with VUE. So it benefits from the optimal performance and clean architecture of VUE. NUXT attempts to be a holistic solution to client and server development and it does deliver - but with some caveats. It is very disciplined and clean and so it provides for better development velocity. It fully supports all modern rendering modes and it is a great solution for all SEO needs since it can be contextual to the nature of each component. It has its own mature set of UI components, but the abstraction over base components and Tailwind is actually a large annoyance. I do not actually recommend relying on NUXT if you have a large set of existing tailwind classes and do not have the time to babysit NUXT when package versions are updated. If you need better server-side support and better authentication support, then NUXT is a good solution. I am not YET convinced that I will deploy this to production." },
    { "label": "Go", "quadrant": 3, "ring": 2, "moved": 0, "description": "For app and API layers, I am much more likely to use .Net, but for distributed devices and critical workflows, GO remains a curious open question when compared to the cost of migrating to Rust." },
    { "label": "Rust", "quadrant": 3, "ring": 2, "moved": 0, "description": "Everyone knows how impressive Rust is. But migrating to Rust has a large cost in time and training. I do not think that it is the right solution for most APIs and apps and is more apt for IoC and critical async workflows. I have yet to complete a practical POC, but I look forward to doing so." },
    { "label": "GRPC", "quadrant": 3, "ring": 2, "moved": 0, "description": "I have not had a need to decrease latency for internal processes, but if I did I would complete a POC on this sooner. Overall, I am not in love with the approach because it feels too much like WCF. I prefer less coupled methods of communication. But I have much to learn." },
    { "label": "GraphQL", "quadrant": 3, "ring": 3, "moved": -1, "description": "GraphQL is something you love or you hate. I loved it until I used it in production for a year. I think it is useful for quickly building dynamic internal tools for operations and reporting. But for what it was meant for (allowing the app team to iterate quickly without API layer team road blocks) … I am not convinced. I think that it is a solution to a critical architectural and organizational flaw. If you have a layered architectural style then I can see why this would feel like a good idea, but in modern styles this is not an issue since each team owns a vertical slice of a logical or technical domain. This comes with just enough security, performance, interoperability, maintenance, and architectural trade offs that I am no longer convinced that the risks outweigh the benefits." }
  ]
}